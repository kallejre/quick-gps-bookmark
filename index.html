<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GPS Batch Capture</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 16px; }
    h2 { margin: 0 0 10px; }
    .card { background: #f6f6f6; padding: 12px; border-radius: 10px; margin: 10px 0; }
    input { width: 100%; padding: 12px; font-size: 16px; border-radius: 10px; border: 1px solid #ddd; }
    button { width: 100%; padding: 14px; margin: 3px 0; font-size: 18px; border-radius: 12px; border: 0; height: 4em; }
    .grid { display: grid; gap: 10px; grid-template-columns: 1fr 1fr; }
    .status { margin-top: 8px; }
    pre { background: #111; color: #eee; padding: 12px; border-radius: 10px; overflow:auto; font-size: 12px; }
    .muted { color: #555; font-size: 13px; }
  </style>
</head>
<body>
  <h2>GPS Batch Capture</h2>

  <div class="card">
    <label for="username"><b>User name</b> <span class="muted">(optional)</span></label>
    <input id="username" placeholder="e.g. Alex (optional)" autocomplete="name" />
    <div class="status" id="status"></div>
    <div class="status" id="gpsStatus"></div>
    <div class="status" id="queueStatus"></div>
  </div>

  <div class="grid">
    <button onclick="tapCategory('BENCH')">BENCH</button>
    <button onclick="tapCategory('BIN')">BIN</button>
    <button onclick="tapCategory('TREE')">TREE</button>
    <button onclick="tapCategory('TABLE')">TABLE</button>
  </div>

  <div class="card">
    <b>Debug (last batch to console)</b>
    <pre id="debug">{}</pre>
  </div>

<script>
  // ===== CONFIG =====
  const SAMPLE_GAP_MS = 2000;         // 2 seconds between points
  const ACCURACY_LIMIT_M = 100;       // require <= 100m accuracy
  const HIGH_ACCURACY = true;

  // Bigger timeouts to reduce "timeout exceeded"
  const GEO_TIMEOUT_MS = 5000;       // 5s per request
  const BROWSER_MAX_AGE_MS = 900;    // allow up to 0.9s browser-level cached to reduce timeouts
  const APP_MAX_AGE_MS = 1000;       // allow up to 1s app-level cached to reduce timeouts

  // Warm-up / retry
  const WARMUP_RETRY_MS = 2500;       // retry interval until we have good fix
  const WARMUP_BADFIX_MAX_MS = 120000;// after 2 min, still keep trying but show stronger message
  const SAMPLE_RETRY_MS = 250; // If initial sample fails, retry after 250ms

  // Batching: flush after 10s of inactivity since last successful capture
  const BATCH_WINDOW_MS = 10000;

  // ===== UI =====
  const statusEl = document.getElementById("status");
  const gpsStatusEl = document.getElementById("gpsStatus");
  const queueStatusEl = document.getElementById("queueStatus");
  const debugEl = document.getElementById("debug");
  const usernameEl = document.getElementById("username");

  function setStatus(msg) { statusEl.textContent = msg; }
  function setGpsStatus(msg) { gpsStatusEl.textContent = msg; }
  function setQueueStatus(msg) { queueStatusEl.textContent = msg; }
  function setDebug(obj) { debugEl.textContent = JSON.stringify(obj, null, 2); }

  // ===== QUEUE / BATCH STATE =====
  const queue = [];
  let batchTimer = null;
  let activeCaptures = 0;

  function updateQueueUI() {
    setQueueStatus(`Queued items: ${queue.length} | Active captures: ${activeCaptures}`);
  }

  function scheduleBatchSend() {
    if (batchTimer) clearTimeout(batchTimer);
    batchTimer = setTimeout(() => flushBatch("timer"), BATCH_WINDOW_MS);
  }

  // ===== GEOLOCATION =====
  function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

  // Continuous GPS watching - updates position as it becomes available
  let watchId = null;
  let watchedPosition = null; // GeolocationPosition - continuously updated by watchPosition
  let lastPositionTimestamp = null; // Track when we last used a position to ensure freshness

  function isGoodFix(pos) {
    return pos && pos.coords && typeof pos.coords.accuracy === "number" && pos.coords.accuracy <= ACCURACY_LIMIT_M;
  }

  function stopWatchingPosition() {
    if (watchId !== null) {
      navigator.geolocation.clearWatch(watchId);
      watchId = null;
    }
  }

  // Get a fresh position from the watch (waits for a new position if needed)
  function getPositionOnce() {
    return new Promise((resolve, reject) => {
      if (!navigator.geolocation) {
        reject(new Error("Geolocation not supported."));
        return;
      }

      const startTime = Date.now();
      const lastUsedTimestamp = lastPositionTimestamp; // Capture current value

      // Wait for a position that's newer than the last one we used
      const checkInterval = setInterval(() => {
        if (watchedPosition && isGoodFix(watchedPosition)) {
          const positionTime = watchedPosition.timestamp;
          
          if (!lastUsedTimestamp || positionTime > lastUsedTimestamp) {
            clearInterval(checkInterval);
            resolve(watchedPosition);
            return;
          }
        }
        
        // Timeout check
        if (Date.now() - startTime > GEO_TIMEOUT_MS) {
          clearInterval(checkInterval);
          if (watchedPosition && isGoodFix(watchedPosition)) {
            // Use whatever we have if timeout, but still check it's different
            const positionTime = watchedPosition.timestamp;
            if (!lastUsedTimestamp || positionTime > lastUsedTimestamp) {
              resolve(watchedPosition);
            } else {
              reject(new Error("Timeout waiting for new GPS position"));
            }
          } else {
            reject(new Error("Timeout waiting for GPS position"));
          }
        }
      }, 100); // Check every 100ms
    });
  }

  function startWatchingPosition() {
    if (!navigator.geolocation) {
      setGpsStatus("‚ùå Geolocation not supported.");
      return;
    }

    watchId = navigator.geolocation.watchPosition(
      (position) => {
        // Update watched position if it's accurate enough
        if (isGoodFix(position)) {
          watchedPosition = position;
        } else {
          // Clear position if accuracy degrades
          watchedPosition = null;
        }
      },
      (error) => {
        const code = error && typeof error.code === "number" ? error.code : null;
        if (code === 1) { // PERMISSION_DENIED
          setGpsStatus("GPS: ‚ùå permission denied. Enable location access in browser settings.");
        } else {
          setGpsStatus(`GPS: ${error.message || error}`);
        }
        watchedPosition = null;
      },
      {
        enableHighAccuracy: HIGH_ACCURACY,
        maximumAge: 0, // Don't use cached positions - always get fresh
        timeout: GEO_TIMEOUT_MS
      }
    );
  }

  async function warmupLoop() {
    const start = Date.now();
    setGpsStatus("GPS warm-up: watching location... (needs HTTPS + permission)");
    
    // Wait for first good position from watch
    while (true) {
      try {
        const pos = await getPositionOnce();

        const acc = Math.round(pos.coords.accuracy);
        if (acc <= ACCURACY_LIMIT_M) {
          setGpsStatus(`GPS warm-up: ‚úÖ good fix (${acc}m). Ready.`);
          return; // stop warmup loop once good fix obtained
        } else {
          const elapsed = Date.now() - start;
          const msg = elapsed > WARMUP_BADFIX_MAX_MS
            ? `GPS warm-up: fix still weak (${acc}m). Try moving outdoors / enabling GPS. Waiting for better fix...`
            : `GPS warm-up: got fix (${acc}m), need ‚â§ ${ACCURACY_LIMIT_M}m. Waiting for better fix...`;
          setGpsStatus(msg);
        }
      } catch (err) {
        const elapsed = Date.now() - start;
        if (elapsed > WARMUP_BADFIX_MAX_MS) {
          setGpsStatus(`GPS warm-up: still waiting for fix. Try moving outdoors / enabling GPS.`);
        } else {
          setGpsStatus(`GPS warm-up: ${err.message || err} (waiting‚Ä¶)`);
        }
      }

      await sleep(WARMUP_RETRY_MS);
    }
  }

  // Get a fresh position - ensures each call gets a new position, not a cached one
  async function getGoodPositionOrThrow() {
    // Wait for a fresh position from the watch
    const pos = await getPositionOnce();
    
    // Mark this timestamp so we don't reuse the same position next time
    lastPositionTimestamp = pos.timestamp;

    const acc = pos.coords.accuracy;
    if (acc > ACCURACY_LIMIT_M) {
      throw new Error(`Accuracy too low: ${Math.round(acc)}m (> ${ACCURACY_LIMIT_M}m)`);
    }
    
    // Return the position directly
    return pos;
  }

  // ===== MAIN: ON TAP =====
  async function tapCategory(category) {
    const user = (usernameEl.value || "").trim(); // optional

    activeCaptures++;
    updateQueueUI();
    setStatus(`Capturing ${category}: point 1‚Ä¶`);

    try {
      // point 1
      const p1 = await getGoodPositionOrThrow();
      const t1 = p1.timestamp;

      setStatus(`Capturing ${category}: point 2 in 2s‚Ä¶`);
      await sleep(SAMPLE_GAP_MS);

      // point 2
      const p2 = await getGoodPositionOrThrow();
      const t2 = p2.timestamp;

      // Send raw points - backend will calculate speed/distance/direction
      const item = {
        category,
        capturedAt: new Date().toISOString(),
        ...(user ? { user } : {}),  // only include if provided
        point1: {
          lat: p1.coords.latitude, lon: p1.coords.longitude,
          accuracyM: p1.coords.accuracy, timestampMs: t1
        },
        point2: {
          lat: p2.coords.latitude, lon: p2.coords.longitude,
          accuracyM: p2.coords.accuracy, timestampMs: t2
        }
      };

      queue.push(item);
      setStatus(`‚úÖ Captured ${category}. Queued.`);
      updateQueueUI();
      scheduleBatchSend();

    } catch (err) {
      console.error(err);
      setStatus(`‚ùå ${category}: ${err.message || err}`);
      // Keep warming up in case we lost fix / moved inside
      warmupLoop().catch((e) => {console.error(e); });
    } finally {
      activeCaptures--;
      updateQueueUI();
    }
  }

  // ===== FLUSH BATCH =====
  function flushBatch(reason) {
    if (batchTimer) { clearTimeout(batchTimer); batchTimer = null; }
    if (queue.length === 0) { setStatus("Nothing to send."); return; }

    const batch = {
      sentAt: new Date().toISOString(),
      reason,
      count: queue.length,
      items: queue.splice(0, queue.length)
    };

    console.log("BATCH_PAYLOAD", batch);
    // Send to backend (save.php)
    fetch("save.php", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(batch)
    })
      .then(async (res) => {
        const text = await res.text();
        let json = {};
        try { json = JSON.parse(text); } catch { }
        if (!res.ok) throw new Error(`HTTP ${res.status}: ${text}`);
        console.log("Backend response:", json);
        setDebug({ batch, backendResponse: json });
        setStatus(`‚úÖ Sent batch (${batch.count}). Inserted: ${json.inserted ?? "?"}`);
      })
      .catch((err) => {
        console.error(err);
        setDebug({ batch, error: String(err) });
        setStatus(`‚ùå Send failed: ${err.message || err}`);
      });

    setDebug(batch);
    setStatus(`üì¶ Batch printed to console (${batch.count} items).`);
    updateQueueUI();
  }

  // ===== STARTUP =====
  updateQueueUI();
  setStatus("Loading... starting GPS watch.");
  // Start watching position immediately
  startWatchingPosition();
  // Start warm-up to wait for first good fix
  warmupLoop().catch(err => {
    console.error(err);
    setGpsStatus(`GPS warm-up failed: ${err.message || err}`);
  });
</script>
<a href="latest.php">Data</a>
</body>
</html>
