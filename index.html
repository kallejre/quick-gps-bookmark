<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GPS Batch Capture</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 16px; }
    h2 { margin: 0 0 10px; }
    .card { background: #f6f6f6; padding: 12px; border-radius: 10px; margin: 10px 0; }
    input { width: 100%; padding: 12px; font-size: 16px; border-radius: 10px; border: 1px solid #ddd; }
    button { width: 100%; padding: 14px; margin: 3px 0; font-size: 18px; border-radius: 12px; border: 0; height: 4em; }
    .grid { display: grid; gap: 10px; grid-template-columns: 1fr 1fr; }
    .status { margin-top: 8px; }
    pre { background: #111; color: #eee; padding: 12px; border-radius: 10px; overflow:auto; font-size: 12px; }
    .muted { color: #555; font-size: 13px; }
  </style>
</head>
<body>
  <h2>GPS Batch Capture</h2>

  <div class="card">
    <label for="username"><b>User name</b> <span class="muted">(optional)</span></label>
    <input id="username" placeholder="e.g. Alex (optional)" autocomplete="name" />
    <div class="status" id="status"></div>
    <div class="status" id="gpsStatus"></div>
    <div class="status" id="queueStatus"></div>
  </div>

  <div class="grid">
    <button onclick="tapCategory('BENCH')">BENCH</button>
    <button onclick="tapCategory('BIN')">BIN</button>
    <button onclick="tapCategory('TREE')">TREE</button>
    <button onclick="tapCategory('TABLE')">TABLE</button>
  </div>

  <div class="card">
    <b>Debug (last batch to console)</b>
    <pre id="debug">{}</pre>
  </div>

<script>
  // ===== CONFIG =====
  const SAMPLE_GAP_MS = 2000;         // 2 seconds between points
  const ACCURACY_LIMIT_M = 40;       // require <= 40m accuracy
  const HIGH_ACCURACY = true;

  // Bigger timeouts to reduce "timeout exceeded"
  const GEO_TIMEOUT_MS = 15000;       // 15s per request
  const BROWSER_MAX_AGE_MS = 900;    // allow up to 0.9s browser-level cached to reduce timeouts
  const POSITION_HISTORY_MS = 5000;   // Keep positions from last 5 seconds

  // Warm-up / retry
  const WARMUP_RETRY_MS = 2500;       // retry interval until we have good fix
  const WARMUP_BADFIX_MAX_MS = 120000;// after 2 min, still keep trying but show stronger message
  const SAMPLE_RETRY_MS = 250; // If initial sample fails, retry after 250ms

  // Batching: flush after 10s of inactivity since last successful capture
  const BATCH_WINDOW_MS = 10000;

  // ===== UI =====
  const statusEl = document.getElementById("status");
  const gpsStatusEl = document.getElementById("gpsStatus");
  const queueStatusEl = document.getElementById("queueStatus");
  const debugEl = document.getElementById("debug");
  const usernameEl = document.getElementById("username");

  function setStatus(msg) { statusEl.textContent = msg; }
  function setGpsStatus(msg) { gpsStatusEl.textContent = msg; }
  function setQueueStatus(msg) { queueStatusEl.textContent = msg; }
  function setDebug(obj) { debugEl.textContent = JSON.stringify(obj, null, 2); }

  // ===== QUEUE / BATCH STATE =====
  const queue = [];
  let batchTimer = null;
  let activeCaptures = 0;

  function updateQueueUI() {
    setQueueStatus(`Queued items: ${queue.length} | Active captures: ${activeCaptures}`);
  }

  function scheduleBatchSend() {
    if (batchTimer) clearTimeout(batchTimer);
    batchTimer = setTimeout(() => flushBatch("timer"), BATCH_WINDOW_MS);
  }

  // ===== GEOLOCATION =====
  function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

  // Dual polling: high accuracy and approximate (like Google Maps)
  let pollIntervalHighAccuracy = null;
  let pollIntervalApproximate = null;
  let positionHistory = []; // Array of { pos, receivedAtMs } - positions from both pollers
  let lastPositionTimestamp = null; // Track when we last used a position to ensure freshness
  const POLL_INTERVAL_MS = 1000; // Poll every second

  function isGoodFix(pos) {
    return pos && pos.coords && typeof pos.coords.accuracy === "number" && pos.coords.accuracy <= ACCURACY_LIMIT_M;
  }

  // Clean up old positions from history (older than POSITION_HISTORY_MS)
  function cleanupPositionHistory() {
    const now = Date.now();
    positionHistory = positionHistory.filter(item => (now - item.receivedAtMs) < POSITION_HISTORY_MS);
  }

  // Get the most accurate position from the last 5 seconds
  function getBestRecentPosition() {
    cleanupPositionHistory();
    if (positionHistory.length === 0) return null;
    
    // Sort by accuracy (lower is better), then by recency
    const sorted = [...positionHistory].sort((a, b) => {
      const accDiff = (a.pos.coords.accuracy || Infinity) - (b.pos.coords.accuracy || Infinity);
      if (Math.abs(accDiff) < 1) {
        // If accuracy is similar, prefer more recent
        return b.receivedAtMs - a.receivedAtMs;
      }
      return accDiff;
    });
    
    return sorted[0].pos;
  }

  function stopPollingPosition() {
    if (pollIntervalHighAccuracy !== null) {
      clearInterval(pollIntervalHighAccuracy);
      pollIntervalHighAccuracy = null;
    }
    if (pollIntervalApproximate !== null) {
      clearInterval(pollIntervalApproximate);
      pollIntervalApproximate = null;
    }
    positionHistory = [];
  }

  // Get a fresh position from the watch (waits for a new position if needed)
  function getPositionOnce() {
    return new Promise((resolve, reject) => {
      if (!navigator.geolocation) {
        reject(new Error("Geolocation not supported."));
        return;
      }

      const startTime = Date.now();
      const lastUsedTimestamp = lastPositionTimestamp; // Capture current value

      // Wait for a position that's newer than the last one we used
      const checkInterval = setInterval(() => {
        cleanupPositionHistory();
        const bestPos = getBestRecentPosition();
        
        if (bestPos) {
          const positionTime = bestPos.timestamp;
          
          if (!lastUsedTimestamp || positionTime > lastUsedTimestamp) {
            clearInterval(checkInterval);
            resolve(bestPos);
            return;
          }
        }
        
        // Timeout check
        if (Date.now() - startTime > GEO_TIMEOUT_MS) {
          clearInterval(checkInterval);
          const bestPos = getBestRecentPosition();
          if (bestPos) {
            const positionTime = bestPos.timestamp;
            if (!lastUsedTimestamp || positionTime > lastUsedTimestamp) {
              resolve(bestPos);
            } else {
              reject(new Error("Timeout waiting for new GPS position"));
            }
          } else {
            reject(new Error("Timeout waiting for GPS position"));
          }
        }
      }, 100); // Check every 100ms
    });
  }

  function pollHighAccuracy() {
    navigator.geolocation.getCurrentPosition(
      (position) => {
        const acc = Math.round(position.coords.accuracy);
        const formattedTime = new Date(position.timestamp).toLocaleString();
        setGpsStatus(`GPS (high): ${acc}m @ ${formattedTime}`);
        
        // Add to history
        positionHistory.push({
          pos: position,
          receivedAtMs: Date.now()
        });
        cleanupPositionHistory();
      },
      (error) => {
        const code = error && typeof error.code === "number" ? error.code : null;
        if (code === 1) { // PERMISSION_DENIED
          setGpsStatus("GPS: âŒ permission denied. Enable location access in browser settings.");
        } else {
          // Don't show errors for high accuracy - approximate will handle it
        }
      },
      {
        enableHighAccuracy: true,
        maximumAge: 0, // Force fresh position - no caching
        timeout: GEO_TIMEOUT_MS
      }
    );
  }

  function pollApproximate() {
    navigator.geolocation.getCurrentPosition(
      (position) => {
        const acc = Math.round(position.coords.accuracy);
        const formattedTime = new Date(position.timestamp).toLocaleString();
        // Only log if it's significantly different or better than high accuracy
        const bestRecent = getBestRecentPosition();
        if (!bestRecent || position.coords.accuracy < bestRecent.coords.accuracy) {
          setGpsStatus(`GPS (approx): ${acc}m @ ${formattedTime}`);
        }
        
        // Add to history
        positionHistory.push({
          pos: position,
          receivedAtMs: Date.now()
        });
        cleanupPositionHistory();
      },
      (error) => {
        const code = error && typeof error.code === "number" ? error.code : null;
        if (code === 1) { // PERMISSION_DENIED
          setGpsStatus("GPS: âŒ permission denied. Enable location access in browser settings.");
        } else {
          // Approximate can fail silently - high accuracy will handle it
        }
      },
      {
        enableHighAccuracy: false, // Approximate mode
        maximumAge: 0, // Force fresh position - no caching
        timeout: GEO_TIMEOUT_MS
      }
    );
  }

  function startPollingPosition() {
    if (!navigator.geolocation) {
      setGpsStatus("âŒ Geolocation not supported.");
      return;
    }

    // Start polling immediately, then every second
    pollHighAccuracy();
    pollApproximate();
    
    // High accuracy poller (GPS) - poll every second
    pollIntervalHighAccuracy = setInterval(() => {
      pollHighAccuracy();
    }, POLL_INTERVAL_MS);

    // Approximate poller (network/cell towers) - poll every second
    pollIntervalApproximate = setInterval(() => {
      pollApproximate();
    }, POLL_INTERVAL_MS);
  }

  async function warmupLoop() {
    const start = Date.now();
    setGpsStatus("GPS warm-up: watching location... (needs HTTPS + permission)");
    
    // Wait for first good position from watch
    while (true) {
      try {
        const pos = await getPositionOnce();

        const acc = Math.round(pos.coords.accuracy);
        if (acc <= ACCURACY_LIMIT_M) {
          setGpsStatus(`GPS warm-up: âœ… good fix (${acc}m). Ready.`);
          return; // stop warmup loop once good fix obtained
        } else {
          const elapsed = Date.now() - start;
          const msg = elapsed > WARMUP_BADFIX_MAX_MS
            ? `GPS warm-up: fix still weak (${acc}m). Try moving outdoors / enabling GPS. Waiting for better fix...`
            : `GPS warm-up: got fix (${acc}m), need â‰¤ ${ACCURACY_LIMIT_M}m. Waiting for better fix...`;
          setGpsStatus(msg);
        }
      } catch (err) {
        const elapsed = Date.now() - start;
        if (elapsed > WARMUP_BADFIX_MAX_MS) {
          setGpsStatus(`GPS warm-up: still waiting for fix. Try moving outdoors / enabling GPS.`);
        } else {
          setGpsStatus(`GPS warm-up: ${err.message || err} (waitingâ€¦)`);
        }
      }

      await sleep(WARMUP_RETRY_MS);
    }
  }

  // Get a fresh position - ensures each call gets a new position, not a cached one
  async function getGoodPositionOrThrow() {
    // Wait for a fresh position from the watch
    const pos = await getPositionOnce();
    
    // Mark this timestamp so we don't reuse the same position next time
    lastPositionTimestamp = pos.timestamp;

    const acc = pos.coords.accuracy;
    if (acc > ACCURACY_LIMIT_M) {
      throw new Error(`Accuracy too low: ${Math.round(acc)}m (> ${ACCURACY_LIMIT_M}m)`);
    }
    
    // Return the position directly
    return pos;
  }

  // ===== MAIN: ON TAP =====
  async function tapCategory(category) {
    const user = (usernameEl.value || "").trim(); // optional

    activeCaptures++;
    updateQueueUI();
    setStatus(`Capturing ${category}: point 1â€¦`);

    try {
      // point 1
      const p1 = await getGoodPositionOrThrow();
      const t1 = p1.timestamp;

      setStatus(`Capturing ${category}: point 2 in 2sâ€¦`);
      await sleep(SAMPLE_GAP_MS);

      // point 2
      const p2 = await getGoodPositionOrThrow();
      const t2 = p2.timestamp;

      // Send raw points - backend will calculate speed/distance/direction
      const item = {
        category,
        capturedAt: new Date().toISOString(),
        ...(user ? { user } : {}),  // only include if provided
        point1: {
          lat: p1.coords.latitude, lon: p1.coords.longitude,
          accuracyM: p1.coords.accuracy, timestampMs: t1
        },
        point2: {
          lat: p2.coords.latitude, lon: p2.coords.longitude,
          accuracyM: p2.coords.accuracy, timestampMs: t2
        }
      };

      queue.push(item);
      setStatus(`âœ… Captured ${category}. Queued.`);
      updateQueueUI();
      scheduleBatchSend();

    } catch (err) {
      console.error(err);
      setStatus(`âŒ ${category}: ${err.message || err}`);
      // Keep warming up in case we lost fix / moved inside
      warmupLoop().catch((e) => {console.error(e); });
    } finally {
      activeCaptures--;
      updateQueueUI();
    }
  }

  // ===== FLUSH BATCH =====
  function flushBatch(reason) {
    if (batchTimer) { clearTimeout(batchTimer); batchTimer = null; }
    if (queue.length === 0) { setStatus("Nothing to send."); return; }

    const batch = {
      sentAt: new Date().toISOString(),
      reason,
      count: queue.length,
      items: queue.splice(0, queue.length)
    };

    console.log("BATCH_PAYLOAD", batch);
    // Send to backend (save.php)
    fetch("save.php", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(batch)
    })
      .then(async (res) => {
        const text = await res.text();
        let json = {};
        try { json = JSON.parse(text); } catch { }
        if (!res.ok) throw new Error(`HTTP ${res.status}: ${text}`);
        console.log("Backend response:", json);
        setDebug({ batch, backendResponse: json });
        setStatus(`âœ… Sent batch (${batch.count}). Inserted: ${json.inserted ?? "?"}`);
      })
      .catch((err) => {
        console.error(err);
        setDebug({ batch, error: String(err) });
        setStatus(`âŒ Send failed: ${err.message || err}`);
      });

    setDebug(batch);
    setStatus(`ðŸ“¦ Batch printed to console (${batch.count} items).`);
    updateQueueUI();
  }

  // ===== STARTUP =====
  updateQueueUI();
  setStatus("Loading... starting GPS polling.");
  // Start polling position immediately
  startPollingPosition();
  // Start warm-up to wait for first good fix
  //warmupLoop().catch(err => {
  //  console.error(err);
  //  setGpsStatus(`GPS warm-up failed: ${err.message || err}`);
  //});
</script>
<a href="latest.php">Data</a>
</body>
</html>
