<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GPS Batch Capture</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 16px; }
    h2 { margin: 0 0 10px; }
    .card { background: #f6f6f6; padding: 12px; border-radius: 10px; margin: 10px 0; }
    input { width: 100%; padding: 12px; font-size: 16px; border-radius: 10px; border: 1px solid #ddd; }
    button { width: 100%; padding: 14px; margin: 3px 0; font-size: 18px; border-radius: 12px; border: 0; height: 4em; }
    .grid { display: grid; gap: 10px; grid-template-columns: 1fr 1fr; }
    .status { margin-top: 8px; }
    pre { background: #111; color: #eee; padding: 12px; border-radius: 10px; overflow:auto; font-size: 12px; }
    .muted { color: #555; font-size: 13px; }
  </style>
</head>
<body>
  <h2>GPS Batch Capture</h2>

  <div class="card">
    <label for="username"><b>User name</b> <span class="muted">(optional)</span></label>
    <input id="username" placeholder="e.g. Alex (optional)" autocomplete="name" />
    <div class="status" id="status"></div>
    <div class="status" id="gpsStatus"></div>
    <div class="status" id="queueStatus"></div>
  </div>

  <div class="grid">
    <button onclick="tapCategory('BENCH')">BENCH</button>
    <button onclick="tapCategory('BIN')">BIN</button>
    <button onclick="tapCategory('TREE')">TREE</button>
    <button onclick="tapCategory('TABLE')">TABLE</button>
  </div>

  <div class="card">
    <b>Debug (last batch to console)</b>
    <pre id="debug">{}</pre>
  </div>

<script>
  // ===== CONFIG =====
  const SAMPLE_GAP_MS = 2000;         // 2 seconds between points
  const ACCURACY_LIMIT_M = 40;       // require <= 40m accuracy
  const HIGH_ACCURACY = true;

  // Bigger timeouts to reduce "timeout exceeded"
  const GEO_TIMEOUT_MS = 15000;       // 15s per request
  const BROWSER_MAX_AGE_MS = 0;    // allow up to 0.9s browser-level cached to reduce timeouts
  const POSITION_HISTORY_MS = 5000;   // Keep positions from last 5 seconds
  const CHECK_INTERVAL_MS = 800;

  // Warm-up / retry
  const WARMUP_RETRY_MS = 2500;       // retry interval until we have good fix
  const WARMUP_BADFIX_MAX_MS = 120000;// after 2 min, still keep trying but show stronger message
  const SAMPLE_RETRY_MS = 250; // If initial sample fails, retry after 250ms

  // Batching: flush after 10s of inactivity since last successful capture
  const BATCH_WINDOW_MS = 10000;

  // ===== UI =====
  const statusEl = document.getElementById("status");
  const gpsStatusEl = document.getElementById("gpsStatus");
  const queueStatusEl = document.getElementById("queueStatus");
  const debugEl = document.getElementById("debug");
  const usernameEl = document.getElementById("username");

  function setStatus(msg) { statusEl.textContent = msg; }
  function setGpsStatus(msg) { gpsStatusEl.textContent = msg; }
  function setQueueStatus(msg) { queueStatusEl.textContent = msg; }
  function setDebug(obj) { debugEl.textContent = JSON.stringify(obj, null, 2); }

  // ===== QUEUE / BATCH STATE =====
  const queue = [];
  let batchTimer = null;
  let activeCaptures = 0;

  function updateQueueUI() {
    setQueueStatus(`Queued items: ${queue.length} | Active captures: ${activeCaptures}`);
  }

  function scheduleBatchSend() {
    if (batchTimer) clearTimeout(batchTimer);
    batchTimer = setTimeout(() => flushBatch("timer"), BATCH_WINDOW_MS);
  }

  // ===== GEOLOCATION =====
  function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

  function isGoodFix(pos) {
    return pos && pos.coords && typeof pos.coords.accuracy === "number" && pos.coords.accuracy <= ACCURACY_LIMIT_M;
  }

  // ===== POSITION WATCHER CLASS =====
  class PositionWatcher {
    constructor(name, options) {
      this.name = name;
      this.options = options;
      this.latest = null;
      this.latestReceivedAtMs = null;
      this.latestSeq = 0; 
      this.error = null;
      this.isActive = false;
      this.watchId = null;
    }

    start() {
      if (this.isActive || !navigator.geolocation) return;

      this.isActive = true;
      this.watchId = navigator.geolocation.watchPosition(
        (position) => {
          this.latest = position;
          this.latestReceivedAtMs = Date.now();
          this.latestSeq++;
          this.error = null;
        },
        (error) => { this.error = error; },
        this.options
      );
    }

    stop() {
      if (this.watchId !== null) {
        navigator.geolocation.clearWatch(this.watchId);
        this.watchId = null;
      }
      this.isActive = false;
      this.latest = null;
      this.error = null;
    }
  }

  // ===== POSITION AGGREGATOR CLASS =====
  class PositionAggregator {
    constructor(watchers, historyMaxAgeMs, checkIntervalMs) {
      this.watchers = watchers;
      this.historyMaxAgeMs = historyMaxAgeMs;
      this.history = []; // { pos, receivedAtMs, source, seq }
      this.updateSeq = 0;
      this._lastConsumedSeq = new Map(); // watcher.name -> last consumed watcher.latestSeq
    }

    start() {
    // no interval needed; we can update history whenever someone asks,
    // but keeping a small interval is OK too.
    if (this.intervalId) return;
    this.intervalId = setInterval(() => this._syncFromWatchers(), 200);
    this._syncFromWatchers();
  }

  stop() {
    if (this.intervalId) clearInterval(this.intervalId);
    this.intervalId = null;
    this.history = [];
    this.updateSeq = 0;
    this._lastConsumedSeq.clear();
  }

  _cleanup(now = Date.now()) {
    this.history = this.history.filter(x => (now - x.receivedAtMs) < this.historyMaxAgeMs);
  }

  _syncFromWatchers() {
    const now = Date.now();
    let added = false;

    for (const w of this.watchers) {
      if (!w.latest) continue;

      const last = this._lastConsumedSeq.get(w.name) ?? 0;
      if (w.latestSeq > last) {
        this._lastConsumedSeq.set(w.name, w.latestSeq);
        this.history.push({
          pos: w.latest,
          receivedAtMs: w.latestReceivedAtMs ?? now,
          source: w.name,
          seq: w.latestSeq,
        });
        added = true;
      }
    }

    this._cleanup(now);
    if (added) this.updateSeq++;
  }

  getBestRecent(requireGood = false) {
    this._syncFromWatchers();
    this._cleanup();

    const candidates = requireGood ? this.history.filter(x => isGoodFix(x.pos)) : this.history;
    if (candidates.length === 0) return null;

    return [...candidates].sort((a, b) => {
      const accA = a.pos.coords.accuracy ?? Infinity;
      const accB = b.pos.coords.accuracy ?? Infinity;
      if (Math.abs(accA - accB) < 1) return b.receivedAtMs - a.receivedAtMs;
      return accA - accB;
    })[0].pos;
  }

  // <-- NEW: when did we last receive an update?
  getLastUpdateTimeMs() {
    this._syncFromWatchers();
    if (this.history.length === 0) return null;
    return Math.max(...this.history.map(x => x.receivedAtMs));
  }
}

  // ===== GPS MANAGER CLASS =====
  class GPSManager {
    constructor() {
      const GEO_TIMEOUT_APPROX_MS = 5000; // 5s for approximate
      
      this.highAccuracyWatcher = new PositionWatcher('high', {
        enableHighAccuracy: true,
        maximumAge: BROWSER_MAX_AGE_MS,
        timeout: GEO_TIMEOUT_MS
      });

      this.approximateWatcher = new PositionWatcher('approx', {
        enableHighAccuracy: false,
        maximumAge: BROWSER_MAX_AGE_MS,
        timeout: GEO_TIMEOUT_APPROX_MS
      });

      this.aggregator = new PositionAggregator(
        [this.highAccuracyWatcher, this.approximateWatcher],
        POSITION_HISTORY_MS,
        CHECK_INTERVAL_MS
      );

      this.lastUsedSeq = 0;
      this.statusUpdateTimer = null;
      this.isRunning = false;
    }

    start() {
      if (!navigator.geolocation) {
        setGpsStatus("âŒ Geolocation not supported.");
        return;
      }

      if (this.isRunning) return; // Already running

      this.isRunning = true;
      this.highAccuracyWatcher.start();
      // Start approximate watcher with a small delay to avoid simultaneous permission requests
      setTimeout(() => {
        if (this.isRunning) {
          this.approximateWatcher.start();
        }
      }, 500);
      
      this.aggregator.start();
      
      // Update status display periodically
      this._updateStatus();
    }

    stop() {
      this.isRunning = false;
      if (this.statusUpdateTimer !== null) {
        clearTimeout(this.statusUpdateTimer);
        this.statusUpdateTimer = null;
      }
      this.highAccuracyWatcher.stop();
      this.approximateWatcher.stop();
      this.aggregator.stop();
      this.lastUsedSeq = 0;
    }

    _updateStatus() {
      if (!this.isRunning) return;

      const best = this.aggregator.getBestRecent(false);
      const lastMs = this.aggregator.getLastUpdateTimeMs();
      const age = lastMs ? Math.round((Date.now() - lastMs) / 1000) : null;

      if (best) {
        const acc = Math.round(best.coords.accuracy);
        const suffix = age !== null ? ` | last update ${age}s ago` : "";
        setGpsStatus(`GPS: ${isGoodFix(best) ? "âœ…" : ""} ${acc}m${suffix}`);
      } else {
        setGpsStatus("GPS: waiting for fixâ€¦");
      }

      this.statusUpdateTimer = setTimeout(() => this._updateStatus(), 1000);
    }


    getPositionOnce() {
      return new Promise((resolve, reject) => {
        const start = Date.now();
        const needSeq = this.lastUsedSeq;
        
        // First, check if we already have a position available
        const immediateBest = this.aggregator.getBestRecent(false);
        if (immediateBest && this.aggregator.updateSeq > needSeq) {
          // We have new data, return it immediately
          this.lastUsedSeq = this.aggregator.updateSeq;
          resolve(immediateBest);
          return;
        }
        
        // If we have any position (even old), wait a bit for a new one, but not too long
        const waitTime = immediateBest ? 100 : GEO_TIMEOUT_MS; // 100ms if we have data, full timeout if not

        const tick = setInterval(() => {
          // Check if we have new data
          if (this.aggregator.updateSeq > needSeq) {
            const best = this.aggregator.getBestRecent(false); // Get best, even if not "good"
            if (best) {
              clearInterval(tick);
              this.lastUsedSeq = this.aggregator.updateSeq;
              resolve(best);
              return;
            }
          }

          // Timeout check
          if (Date.now() - start > waitTime) {
            clearInterval(tick);
            const best = this.aggregator.getBestRecent(false); // Get best, even if not "good"
            if (best) {
              // Return best available, even if it's the same sequence
              this.lastUsedSeq = this.aggregator.updateSeq;
              resolve(best);
            } else {
              reject(new Error("Timeout waiting for GPS position - no position data available"));
            }
          }
        }, 150);
      });
    }
    
    getLastUpdateMs() {
      return this.aggregator.getLastUpdateTimeMs();
    }

    async getGoodPositionOrThrow() {
      const pos = await this.getPositionOnce();
      
      const acc = pos.coords.accuracy;
      if (acc > ACCURACY_LIMIT_M) {
        throw new Error(`Accuracy too low: ${Math.round(acc)}m (> ${ACCURACY_LIMIT_M}m)`);
      }
      
      return pos;
    }
  }

  // Global GPS instance
  const gps = new GPSManager();

  // Legacy function wrappers for backward compatibility
  function startWatchingPosition() {
    gps.start();
  }

  function stopWatchingPosition() {
    gps.stop();
  }

  function getPositionOnce() {
    return gps.getPositionOnce();
  }

  async function getGoodPositionOrThrow() {
    return gps.getGoodPositionOrThrow();
  }

  async function warmupLoop() {
    const start = Date.now();
    setGpsStatus("GPS warm-up: watching location... (needs HTTPS + permission)");
    
    // Wait for first good position
    while (true) {
      try {
        const pos = await gps.getPositionOnce();

        const acc = Math.round(pos.coords.accuracy);
        if (acc <= ACCURACY_LIMIT_M) {
          setGpsStatus(`GPS warm-up: âœ… good fix (${acc}m). Ready.`);
          return; // stop warmup loop once good fix obtained
        } else {
          const elapsed = Date.now() - start;
          const msg = elapsed > WARMUP_BADFIX_MAX_MS
            ? `GPS warm-up: fix still weak (${acc}m). Try moving outdoors / enabling GPS. Waiting for better fix...`
            : `GPS warm-up: got fix (${acc}m), need â‰¤ ${ACCURACY_LIMIT_M}m. Waiting for better fix...`;
          setGpsStatus(msg);
        }
      } catch (err) {
        const elapsed = Date.now() - start;
        if (elapsed > WARMUP_BADFIX_MAX_MS) {
          setGpsStatus(`GPS warm-up: still waiting for fix. Try moving outdoors / enabling GPS.`);
        } else {
          setGpsStatus(`GPS warm-up: ${err.message || err} (waitingâ€¦)`);
        }
      }

      await sleep(WARMUP_RETRY_MS);
    }
  }

  // ===== MAIN: ON TAP =====
  async function tapCategory(category) {
    const user = (usernameEl.value || "").trim(); // optional

    activeCaptures++;
    updateQueueUI();
    setStatus(`Capturing ${category}: point 1â€¦`);

    try {
      // point 1
      const p1 = await getGoodPositionOrThrow();
      const t1 = p1.timestamp;

      setStatus(`Capturing ${category}: point 2 in 2sâ€¦`);
      await sleep(SAMPLE_GAP_MS);

      // point 2
      const p2 = await getGoodPositionOrThrow();
      const t2 = p2.timestamp;

      // Send raw points - backend will calculate speed/distance/direction
      const item = {
        category,
        capturedAt: new Date().toISOString(),
        ...(user ? { user } : {}),  // only include if provided
        point1: {
          lat: p1.coords.latitude, lon: p1.coords.longitude,
          accuracyM: p1.coords.accuracy, timestampMs: t1
        },
        point2: {
          lat: p2.coords.latitude, lon: p2.coords.longitude,
          accuracyM: p2.coords.accuracy, timestampMs: t2
        }
      };

      queue.push(item);
      setStatus(`âœ… Captured ${category}. Queued.`);
      updateQueueUI();
      scheduleBatchSend();

    } catch (err) {
      console.error(err);
      setStatus(`âŒ ${category}: ${err.message || err}`);
      // Keep warming up in case we lost fix / moved inside
      //warmupLoop().catch((e) => {console.error(e); });
    } finally {
      activeCaptures--;
      updateQueueUI();
    }
  }

  // ===== FLUSH BATCH =====
  function flushBatch(reason) {
    if (batchTimer) { clearTimeout(batchTimer); batchTimer = null; }
    if (queue.length === 0) { setStatus("Nothing to send."); return; }

    const batch = {
      sentAt: new Date().toISOString(),
      reason,
      count: queue.length,
      items: queue.splice(0, queue.length)
    };

    console.log("BATCH_PAYLOAD", batch);
    // Send to backend (save.php)
    fetch("save.php", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(batch)
    })
      .then(async (res) => {
        const text = await res.text();
        let json = {};
        try { json = JSON.parse(text); } catch { }
        if (!res.ok) throw new Error(`HTTP ${res.status}: ${text}`);
        console.log("Backend response:", json);
        setDebug({ batch, backendResponse: json });
        setStatus(`âœ… Sent batch (${batch.count}). Inserted: ${json.inserted ?? "?"}`);
      })
      .catch((err) => {
        console.error(err);
        setDebug({ batch, error: String(err) });
        setStatus(`âŒ Send failed: ${err.message || err}`);
      });

    setDebug(batch);
    setStatus(`ðŸ“¦ Batch printed to console (${batch.count} items).`);
    updateQueueUI();
  }

  // ===== STARTUP =====
  updateQueueUI();
  setStatus("Loading... starting GPS watch.");
  // Start GPS watchers immediately
  gps.start();
  // Start warm-up to wait for first good fix
  //warmupLoop().catch(err => {
  //  console.error(err);
  //  setGpsStatus(`GPS warm-up failed: ${err.message || err}`);
  //});
</script>
<a href="latest.html">Data</a> | <a href="map.html" target="_blank">Map</a>
</body>
</html>
